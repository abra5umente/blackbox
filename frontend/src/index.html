<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Blackbox</title>
    <link href="/output.css" rel="stylesheet" />
  </head>
  <body class="font-sans m-0 text-gray-200 bg-gray-900">
    <header class="px-4 py-3 bg-gray-800 border-b border-gray-700">
      <strong class="text-white">Blackbox</strong>
    </header>
    <div class="flex gap-2 px-4 py-2 bg-gray-800 border-b border-gray-700">
      <div class="tab px-3 py-2 rounded-md cursor-pointer bg-blue-600 text-white ring-2 ring-blue-400 hover:bg-blue-700 transition-colors" data-tab="record">Record</div>
      <div class="tab px-3 py-2 rounded-md cursor-pointer bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors" data-tab="transcribe">Transcribe</div>
      <div class="tab px-3 py-2 rounded-md cursor-pointer bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors" data-tab="rt">Record & Transcribe & Summarise</div>
      <div class="tab px-3 py-2 rounded-md cursor-pointer bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors" data-tab="summarise">Summarise</div>
      <div class="tab px-3 py-2 rounded-md cursor-pointer bg-gray-700 text-gray-300 hover:bg-gray-600 transition-colors" data-tab="settings">Settings</div>
    </div>

    <section id="record" class="page block p-4">
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="recWithMic" checked class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Use Microphone
        </label>
      </div>
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="recDictation" class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Dictation mode (mic only)
        </label>
      </div>
      <div class="my-3">
        <button id="btnStart" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Start Recording</button>
        <button id="btnStop" class="bg-gray-700 hover:bg-gray-600 text-gray-200 border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed ml-2">Stop</button>
      </div>
      <div class="my-3"><div id="recStatus" class="text-gray-400 text-sm">Idle</div></div>
      
      <!-- Spectrum Analyzer for Record tab -->
      <div class="my-4">
        <div class="text-gray-300 text-sm mb-2">Audio Activity</div>
        <div id="recSpectrum" class="bg-gray-800 border border-gray-700 rounded-md p-3 h-24 flex items-end justify-between gap-1">
          <!-- Spectrum bars will be generated here -->
        </div>
      </div>
    </section>

    <section id="transcribe" class="page hidden p-4">
      <div class="my-3">
        <button id="btnPickWav" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors">Choose WAV from OutDir</button>
        <span id="pickedWav" class="text-gray-400 text-sm ml-3"></span>
      </div>
      <div class="my-3">
        <button id="btnTranscribe" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Transcribe</button>
      </div>
      <div class="my-3"><div id="transcribeLog" class="whitespace-pre-wrap bg-gray-900 border border-gray-700 rounded-md p-3 max-h-56 overflow-auto text-sm"></div></div>
    </section>

    <section id="rt" class="page hidden p-4">
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="rtWithMic" checked class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Use Microphone
        </label>
      </div>
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="rtDictation" class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Dictation mode (mic only)
        </label>
      </div>
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="rtLocalAI" class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Local AI summarisation
        </label>
      </div>
      <div class="my-3">
        <button id="btnRTStart" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed">Begin</button>
        <button id="btnRTStop" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed ml-2" disabled>Stop Recording</button>
      </div>
      <div class="my-3"><div id="rtLog" class="whitespace-pre-wrap bg-gray-900 border border-gray-700 rounded-md p-3 max-h-56 overflow-auto text-sm"></div></div>
      
      <!-- Spectrum Analyzer for RT tab -->
      <div class="my-4">
        <div class="text-gray-300 text-sm mb-2">Audio Activity</div>
        <div id="rtSpectrum" class="bg-gray-800 border border-gray-700 rounded-md p-3 h-24 flex items-end justify-between gap-1">
          <!-- Spectrum bars will be generated here -->
        </div>
      </div>
    </section>

    <section id="summarise" class="page hidden p-4">
      <div class="my-3">
        <button id="btnPickTxt" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors">Choose TXT from OutDir</button>
        <span id="pickedTxt" class="text-gray-400 text-sm ml-3"></span>
      </div>
      <div class="my-3">
        <label class="flex items-center gap-2 text-gray-300 cursor-pointer">
          <input type="checkbox" id="summariseLocalAI" class="w-4 h-4 text-blue-500 bg-gray-700 border-gray-600 rounded focus:ring-blue-500 focus:ring-2" />
          Local AI summarisation
        </label>
      </div>
      <div class="my-3">
        <button id="btnSummarise" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>Summarise</button>
      </div>
      <div class="my-3"><div id="summariseLog" class="whitespace-pre-wrap bg-gray-900 border border-gray-700 rounded-md p-3 max-h-56 overflow-auto text-sm"></div></div>
    </section>

    <section id="settings" class="page hidden p-4">
      <div class="my-3">
        <label class="block mb-2 text-gray-300">Output Directory</label>
        <input type="text" id="outDir" placeholder="./out" class="bg-gray-700 text-gray-200 border border-gray-600 rounded-md px-3 py-2 w-96 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
      </div>
      
      <div class="my-6 border-t border-gray-700 pt-4">
        <h3 class="text-lg font-semibold text-white mb-3">Local AI Settings</h3>
        <div class="text-gray-400 text-sm mb-3">Configure local AI parameters. Use the checkboxes in the Summarise and Record & Transcribe & Summarise tabs to enable local AI.</div>
        
        <div class="my-3">
          <label class="block mb-2 text-gray-300">Model File</label>
          <div class="flex gap-2">
            <input type="text" id="llamaModel" placeholder="Select model file..." class="bg-gray-700 text-gray-200 border border-gray-600 rounded-md px-3 py-2 flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" readonly />
            <button id="btnPickModel" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors">Browse</button>
          </div>
        </div>
        
        <div class="my-3">
          <label class="block mb-2 text-gray-300">Temperature</label>
          <input type="number" id="llamaTemp" min="0" max="2" step="0.1" placeholder="0.1" class="bg-gray-700 text-gray-200 border border-gray-600 rounded-md px-3 py-2 w-32 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
        </div>
        
        <div class="my-3">
          <label class="block mb-2 text-gray-300">Context Window</label>
          <input type="number" id="llamaContext" min="1024" max="131072" step="1024" placeholder="32000" class="bg-gray-700 text-gray-200 border border-gray-600 rounded-md px-3 py-2 w-32 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
        </div>
        
        <div class="my-3">
          <label class="block mb-2 text-gray-300">Server API Key</label>
          <input type="password" id="llamaAPIKey" placeholder="API key for llama-server authentication..." class="bg-gray-700 text-gray-200 border border-gray-600 rounded-md px-3 py-2 w-96 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
          <div class="text-gray-400 text-xs mt-1">This sets the API key that llama-server will use for authentication</div>
        </div>
      </div>
      
      <div class="my-3">
        <button id="btnSaveSettings" class="bg-blue-500 hover:bg-blue-600 text-white border-0 rounded-md px-3 py-2 cursor-pointer transition-colors">Save Settings</button>
      </div>
      <div class="my-3"><div id="settingsInfo" class="text-gray-400 text-sm"></div></div>
    </section>

    <script src="/wailsjs/runtime/runtime.js"></script>
    <script src="/wailsjs/go/ui/App.js"></script>
    <script>
      const setActive = (name) => {
        document.querySelectorAll('.tab').forEach(t => {
          if (t.dataset.tab === name) {
            t.classList.add('bg-blue-600', 'text-white', 'ring-2', 'ring-blue-400');
            t.classList.remove('bg-gray-700', 'text-gray-300');
          } else {
            t.classList.add('bg-gray-700', 'text-gray-300');
            t.classList.remove('bg-blue-600', 'text-white', 'ring-2', 'ring-blue-400');
          }
        });
        document.querySelectorAll('.page').forEach(p => {
          if (p.id === name) {
            p.classList.remove('hidden');
            p.classList.add('block');
          } else {
            p.classList.add('hidden');
            p.classList.remove('block');
          }
        });
      };
      let pickedTxt = '';
      document.getElementById('btnPickTxt').onclick = async () => {
        const s = await App().GetSettings();
        const outDir = s.out_dir || s.OutDir || './out';
        const f = await App().PickTxtFromOutDir();
        if (f) { pickedTxt = f; document.getElementById('pickedTxt').textContent = f; document.getElementById('btnSummarise').disabled = false; }
      };
      document.getElementById('btnSummarise').onclick = async () => {
        document.getElementById('summariseLog').textContent = 'Running...';
        try {
          // Update settings with current checkbox state
          const useLocalAI = document.getElementById('summariseLocalAI').checked;
          const currentSettings = await App().GetSettings();
          const updatedSettings = {
            ...currentSettings,
            use_local_ai: useLocalAI
          };
          await App().SaveSettings(JSON.stringify(updatedSettings));
          
          const msg = await App().Summarise(pickedTxt);
          document.getElementById('summariseLog').textContent = msg;
        } catch (e) {
          document.getElementById('summariseLog').textContent = 'Error: ' + e;
        }
      };
      document.querySelectorAll('.tab').forEach(tab => tab.addEventListener('click', () => setActive(tab.dataset.tab)));

      // Wails bindings
      const App = () => (window.go && window.go.ui && window.go.ui.App) ? window.go.ui.App : null;

      // Settings
      const loadSettings = async () => {
        try {
          const s = await App().GetSettings();
          document.getElementById('outDir').value = (s && (s.out_dir || s.OutDir)) || './out';
          
          // Load local AI settings
          const useLocalAI = s && s.use_local_ai;
          document.getElementById('summariseLocalAI').checked = useLocalAI;
          document.getElementById('rtLocalAI').checked = useLocalAI;
          document.getElementById('llamaModel').value = (s && s.llama_model) || '';
          document.getElementById('llamaTemp').value = (s && s.llama_temp) || '0.1';
          document.getElementById('llamaContext').value = (s && s.llama_context) || '32000';
          document.getElementById('llamaAPIKey').value = (s && s.llama_api_key) || '';
        } catch (e) {}
      };
      const saveSettings = async () => {
        const cfg = { 
          out_dir: document.getElementById('outDir').value,
          use_local_ai: false, // This is now controlled by individual tab checkboxes
          llama_model: document.getElementById('llamaModel').value,
          llama_temp: parseFloat(document.getElementById('llamaTemp').value) || 0.1,
          llama_context: parseInt(document.getElementById('llamaContext').value) || 32000,
          llama_api_key: document.getElementById('llamaAPIKey').value
        };
        const res = await App().SaveSettings(JSON.stringify(cfg));
        document.getElementById('settingsInfo').textContent = 'Saved: ' + ((res && (res.out_dir || res.OutDir)) || '');
      };

      // Real Audio Spectrum Analyzer using Backend Audio Data
      class RealSpectrumAnalyzer {
        constructor(containerId, barCount = 32) {
          this.container = document.getElementById(containerId);
          this.barCount = barCount;
          this.bars = [];
          this.isActive = false;
          this.animationId = null;
          this.audioData = { loopback: [], microphone: [] };
          this.isInitialized = false;
          this.lastAudioUpdate = 0;
          this.init();
        }

        async init() {
          try {
            // Create spectrum bars
            for (let i = 0; i < this.barCount; i++) {
              const bar = document.createElement('div');
              bar.className = 'bg-gray-600 rounded-sm transition-all duration-50 ease-out';
              bar.style.width = '8px';
              bar.style.minHeight = '8px';
              bar.style.maxHeight = '80px';
              this.container.appendChild(bar);
              this.bars.push(bar);
            }
            
            // Set initial idle state
            this.setIdleState();
            
            // Initialize Wails event listener for audio data
            this.initializeAudioListener();
            this.isInitialized = true;
          } catch (error) {
            console.error('Failed to initialize audio analyzer:', error);
            this.setIdleState();
          }
        }

        initializeAudioListener() {
          // Listen for audio data events from the Go backend
          if (window.go && window.go.runtime && window.go.runtime.EventsOn) {
            window.go.runtime.EventsOn("audioData", (data) => {
              this.handleAudioData(data);
            });
          } else if (window.runtime && window.runtime.EventsOn) {
            // Alternative Wails runtime binding
            window.runtime.EventsOn("audioData", (data) => {
              this.handleAudioData(data);
            });
          }
        }

        handleAudioData(data) {
          if (!this.isActive || !data) return;

          try {
            const source = data.source;
            
            // Handle different data formats from Go backend
            let samples = [];
            
            if (data.data instanceof ArrayBuffer) {
              // Direct ArrayBuffer
              samples = new Int16Array(data.data);
            } else if (data.data instanceof Uint8Array) {
              // Uint8Array - convert to Int16Array
              samples = new Int16Array(data.data.buffer, data.data.byteOffset, data.data.byteLength / 2);
            } else if (Array.isArray(data.data)) {
              // Array of numbers
              samples = new Int16Array(data.data);
            } else if (typeof data.data === 'string') {
              // Base64 encoded string - decode
              try {
                const binaryString = atob(data.data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                samples = new Int16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);
              } catch (e) {
                return;
              }
            } else {
              return;
            }
            
            // Store audio data for analysis
            if (source === 'loopback') {
              this.audioData.loopback = Array.from(samples);
            } else if (source === 'microphone') {
              this.audioData.microphone = Array.from(samples);
            }
            
            this.lastAudioUpdate = Date.now();
            
            // Don't call updateSpectrum here - let the 60fps loop handle it
          } catch (error) {
            // Silent error handling for production
          }
        }

        startRecording(withMic = true, dictation = false) {
          this.isActive = true;
          this.audioData = { loopback: [], microphone: [] };
          this.lastAudioUpdate = Date.now();
          
          // Start the 60fps animation loop
          this.animate();
        }

        stopRecording() {
          this.isActive = false;
          
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
          }

          // Clear audio data
          this.audioData = { loopback: [], microphone: [] };

          // Return to idle state
          this.setIdleState();
        }

        setIdleState() {
          // Create subtle breathing effect when idle
          this.bars.forEach((bar, index) => {
            const idleHeight = 8 + Math.sin(index * 0.3) * 3;
            bar.style.height = idleHeight + 'px';
            bar.className = 'bg-gray-600 rounded-sm transition-all duration-2000 ease-in-out';
          });
        }

        updateSpectrum() {
          if (!this.isActive) return;

          // Combine loopback and microphone data
          let combinedData = [];
          
          if (this.audioData.loopback.length > 0) {
            combinedData = combinedData.concat(this.audioData.loopback);
          }
          
          if (this.audioData.microphone.length > 0) {
            combinedData = combinedData.concat(this.audioData.microphone);
          }

          // Check if we have recent audio data
          const timeSinceAudio = Date.now() - this.lastAudioUpdate;
          
          if (combinedData.length === 0 || timeSinceAudio > 1000) {
            // No audio data or stale data, use enhanced fallback animation
            this.bars.forEach((bar, index) => {
              const time = Date.now() * 0.001;
              const height = 8 + Math.sin(time * 2 + index * 0.3) * 8; // More movement
              bar.style.height = height + 'px';
              bar.className = 'bg-gray-600 rounded-sm transition-all duration-50 ease-out';
            });
            return;
          }

          // Ultra-aggressive frequency analysis for maximum reactivity
          this.bars.forEach((bar, index) => {
            // Calculate energy in this frequency band
            const bandStart = Math.floor((index / this.barCount) * combinedData.length);
            const bandEnd = Math.floor(((index + 1) / this.barCount) * combinedData.length);
            
            let energy = 0;
            for (let i = bandStart; i < bandEnd && i < combinedData.length; i++) {
              energy += Math.abs(combinedData[i]);
            }
            
            // Ultra-aggressive normalization for maximum sensitivity
            const avgEnergy = energy / Math.max(1, bandEnd - bandStart);
            
            // Extremely sensitive normalization - bars will move with any sound
            const normalizedEnergy = Math.min(1, avgEnergy / 1000); // 40x more sensitive than before
            
            // Aggressive exponential scaling for dramatic response
            const scaledEnergy = Math.pow(normalizedEnergy, 0.3); // Very aggressive scaling
            
            // Maximum height range for dramatic movement
            const height = Math.max(8, Math.min(80, 
              8 + scaledEnergy * 72
            ));
            
            bar.style.height = height + 'px';
            
            // Dynamic color based on audio intensity with enhanced sensitivity
            const intensity = height / 80;
            if (intensity > 0.7) {
              bar.className = 'bg-gray-400 rounded-sm transition-all duration-50 ease-out';
            } else if (intensity > 0.4) {
              bar.className = 'bg-gray-500 rounded-sm transition-all duration-50 ease-out';
            } else {
              bar.className = 'bg-gray-600 rounded-sm transition-all duration-50 ease-out';
            }
          });
        }

        animate() {
          if (!this.isActive) return;

          // Always update spectrum at 60fps for smooth animation
          this.updateSpectrum();

          // Use requestAnimationFrame for consistent 60fps timing
          this.animationId = requestAnimationFrame(() => this.animate());
        }
      }

      // Record
      let currentWav = '';
      document.getElementById('btnStart').onclick = async () => {
        const useMic = document.getElementById('recWithMic').checked;
        const dict = document.getElementById('recDictation').checked;
        const p = dict ? await App().StartRecordingAdvanced(useMic, true) : await App().StartRecording(useMic);
        currentWav = p;
        document.getElementById('recStatus').textContent = 'Recording to ' + p;
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStop').disabled = false;
      };
      document.getElementById('btnStop').onclick = async () => {
        const p = await App().StopRecording();
        document.getElementById('recStatus').textContent = 'Saved: ' + p;
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnStop').disabled = true;
      };

      // Transcribe single
      let pickedWav = '';
      document.getElementById('btnPickWav').onclick = async () => {
        const s = await App().GetSettings();
        const outDir = s.out_dir || s.OutDir || './out';
        const f = await App().PickWavFromOutDir();
        if (f) { pickedWav = f; document.getElementById('pickedWav').textContent = f; document.getElementById('btnTranscribe').disabled = false; }
      };
      document.getElementById('btnTranscribe').onclick = async () => {
        document.getElementById('transcribeLog').textContent = 'Running...';
        try {
          const txt = await App().Transcribe(pickedWav);
          document.getElementById('transcribeLog').textContent = 'Done: ' + txt;
        } catch (e) {
          document.getElementById('transcribeLog').textContent = 'Error: ' + e;
        }
      };

      // Record+Transcribe+Summarise
      let rtWav = '';
      document.getElementById('btnRTStart').onclick = async () => {
        const useMic = document.getElementById('rtWithMic').checked;
        const dict = document.getElementById('rtDictation').checked;
        rtWav = dict ? await App().StartRecordingAdvanced(useMic, true) : await App().StartRecording(useMic);
        document.getElementById('rtLog').textContent = 'Recording to ' + rtWav + '\nClick Stop when ready.';
        document.getElementById('btnRTStart').disabled = true;
        document.getElementById('btnRTStop').disabled = false;
      };
      document.getElementById('btnRTStop').onclick = async () => {
        document.getElementById('btnRTStop').disabled = true;
        const p = await App().StopRecording();
        document.getElementById('rtLog').textContent = 'Saved: ' + p + '\nTranscribing...';
        try {
          const txt = await App().Transcribe(p);
          document.getElementById('rtLog').textContent += '\nTranscribed: ' + txt + '\nSummarising...';
          const msg = await App().Summarise(txt);
          document.getElementById('rtLog').textContent += '\n' + msg;
        } catch (e) {
          document.getElementById('rtLog').textContent += '\nError: ' + e;
        }
        document.getElementById('btnRTStart').disabled = false;
      };

      document.getElementById('btnSaveSettings').onclick = saveSettings;
      
      // Model picker
      document.getElementById('btnPickModel').onclick = async () => {
        try {
          const modelPath = await App().PickModelFile();
          if (modelPath) {
            document.getElementById('llamaModel').value = modelPath;
          }
        } catch (e) {
          console.error('Failed to pick model:', e);
        }
      };

      // Initialize spectrum analyzers
      const recSpectrum = new RealSpectrumAnalyzer('recSpectrum');
      const rtSpectrum = new RealSpectrumAnalyzer('rtSpectrum');

      // Update record button handlers to control spectrum analyzer
      document.getElementById('btnStart').onclick = async () => {
        const useMic = document.getElementById('recWithMic').checked;
        const dict = document.getElementById('recDictation').checked;
        const p = dict ? await App().StartRecordingAdvanced(useMic, true) : await App().StartRecording(useMic);
        currentWav = p;
        document.getElementById('recStatus').textContent = 'Recording to ' + p;
        document.getElementById('btnStart').disabled = true;
        document.getElementById('btnStop').disabled = false;
        recSpectrum.startRecording(useMic, dict); // Start spectrum analyzer
      };

      document.getElementById('btnStop').onclick = async () => {
        const p = await App().StopRecording();
        document.getElementById('recStatus').textContent = 'Saved: ' + p;
        document.getElementById('btnStart').disabled = false;
        document.getElementById('btnStop').disabled = true;
        recSpectrum.stopRecording(); // Stop spectrum analyzer
      };

      document.getElementById('btnRTStart').onclick = async () => {
        const useMic = document.getElementById('rtWithMic').checked;
        const dict = document.getElementById('rtDictation').checked;
        rtWav = dict ? await App().StartRecordingAdvanced(useMic, true) : await App().StartRecording(useMic);
        document.getElementById('rtLog').textContent = 'Recording to ' + rtWav + '\nClick Stop when ready.';
        document.getElementById('btnRTStart').disabled = true;
        document.getElementById('btnRTStop').disabled = false;
        rtSpectrum.startRecording(useMic, dict); // Start spectrum analyzer
      };

      document.getElementById('btnRTStop').onclick = async () => {
        document.getElementById('btnRTStop').disabled = true;
        const p = await App().StopRecording();
        document.getElementById('rtLog').textContent = 'Saved: ' + p + '\nTranscribing...';
        rtSpectrum.stopRecording(); // Stop spectrum analyzer
        try {
          const txt = await App().Transcribe(p);
          document.getElementById('rtLog').textContent += '\nTranscribed: ' + txt + '\nSummarising...';
          
          // Update settings with current checkbox state
          const useLocalAI = document.getElementById('rtLocalAI').checked;
          const currentSettings = await App().GetSettings();
          const updatedSettings = {
            ...currentSettings,
            use_local_ai: useLocalAI
          };
          await App().SaveSettings(JSON.stringify(updatedSettings));
          
          const msg = await App().Summarise(txt);
          document.getElementById('rtLog').textContent += '\n' + msg;
        } catch (e) {
          document.getElementById('rtLog').textContent += '\nError: ' + e;
        }
        document.getElementById('btnRTStart').disabled = false;
      };

      loadSettings();
    </script>
  </body>
</html>
